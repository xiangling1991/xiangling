1、STRATEGY---策略模式---->对象行为型模式
a.意图-->定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。使得算法可独立于使用
		 它的客户而变化。
b.动机-->许多算法可对一个正文交流进行分行。将这些算法硬编进使用它们的类中是不可取的，原因如下：
		1)需要换行功能的客户程序如果直接包含换行算法的代码的话将会变得复杂，这使得客户程序庞大并且难以维护，尤其当其需要支持多种换行算法时问题会更加严重。
		2)不同的时候需要不同的算法，我们不想支持我们并不适用的换行算法。
		3)当换行功能是客户程序的一个难以分隔的成分时，增加新的换行算法或改变现有算法将十分困难。
此时，我们可以定义一些类来封装不同的换行算法，一个这种封装方法称为一个策略,如图所示：
———————————————					        —————————————————
| Composition |<>——————————————————————>|  Compositor   |   <<----抽象类
———————————————							—————————————————
| Traverse()  |							|	Compose()   |
| Repair()    |							—————————————————
———————————————									/\
							———————————————————/--\——————————————————
							|				    |					|
					 ——————————————————   ——————————————————      ——————————————————
					 |SimpleCompositor|   |  TexCompositor |      | ArrayCompositor|
  					 ———————————————————  ——————————————————      ——————————————————
					 | Compose()      |   | Compose()      |      |Compose()	   |
					 ——————————————————   ——————————————————      ——————————————————

Composition类负责维护和更新一个正文浏览程序中显示的正文换行，换行策略是由Compositor类的各个子类肚子实现。
Composition维护对Compositor对象的一个引用，一旦Composition重新格式化它的正文，他就将这个职责转发给它的Compositor对象。Composition的客户指定应该使用哪一种Compositor的方式是直接将它想要的Compositor装入Composition中。

c.适用性--->1)许多相关的类仅仅是行为有异。"策略"提供了一种用多个行为中的一个行为来配置一个类的方法。
			2)需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。
			3)算法使用客户不应该知道的数据。可以使用策略模式以避免暴漏复杂的、与算法相关的数据结构。
			4)一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。

d:缺点--->1)客户必须了解不同的Strategy，就是一个客户要选择一个合适的Strategy就必须知道			这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这		  些不同行为变体与客户相关的行为时，才需要使用Strategy模式。
		  2)Strategy和Context之间的通信开销。
		  3)增加了对象的数目。